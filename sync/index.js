// Generated by CoffeeScript 1.7.1
"use strict";
var FS, Q, Rsync, Sync, async, events, exec, fs, path, request, util,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

FS = require("q-io/fs");

fs = require("fs-extra");

async = require("async-q");

Q = require("q");

path = require("path");

exec = require('child_process').exec;

events = require("events");

request = require("request");

util = require("util");

Rsync = require("rsync");

Sync = (function(_super) {
  __extends(Sync, _super);

  Sync.prototype.COMMANDS = {
    "sync-http": "syncHttp",
    "sync-backup": "syncGit",
    "sync-local": "syncLocal",
    "sync-reset": "syncReset"
  };

  function Sync(args) {
    this.config = args.config, this.logger = args.logger;
    this._source = this.config.get("folder:backup");
    this._dest = this.config.get("folder:dest");
    this._flags = {};
    this._gitUrl = this.config.get("git:url");
    this._gitDir = path.join(this._source, '.git');
    this._rsync = new Rsync({
      debug: true
    }).flags('avz').set('delete').exclude(this.config.get("syncIgnore"));
    this._queue = async.queue((function(_this) {
      return function(task) {
        var commandName;
        commandName = _this.COMMANDS[task.command.name];
        return _this[commandName](task.command);
      };
    })(this));
  }

  Sync.initFolders = function() {
    var args;
    args = Array.prototype.slice.call(arguments, 0);
    return async.each(args, function(file) {
      return FS.makeTree(file);
    });
  };

  Sync.prototype.updateFlagIndicators = function() {
    var flag, flags, indicators;
    indicators = this.config.get("indicator");
    flags = (function() {
      var _results;
      _results = [];
      for (flag in indicators) {
        _results.push(flag);
      }
      return _results;
    })();
    return async.each(flags, (function(_this) {
      return function(flag) {
        return FS.exists(path.join(_this._dest, indicators[flag])).then(function(result) {
          return _this._flags[flag] = result;
        });
      };
    })(this));
  };

  Sync.prototype.pushCommand = function(command) {
    var deferred;
    deferred = Q.defer();
    this._queue.push({
      command: command
    }).then((function(_this) {
      return function(result) {
        return deferred.resolve("success");
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        _this.logger.error(err);
        return deferred.reject(err);
      };
    })(this)).done();
    return deferred.promise;
  };

  Sync.prototype._checkRepositoryStatus = function() {
    var deferred;
    this.logger.info("start to check git repository status in '" + this._source + "'");
    deferred = Q.defer();
    exec(this._wrapGit("git status"), {
      cwd: this._source
    }, (function(_this) {
      return function(err, stdout, stderr) {
        _this.logger.info("CHECK GIT STATUS result:\n" + (stdout !== "" ? stdout : stderr));
        if (stderr !== "") {
          return deferred.resolve("not git");
        } else {
          return deferred.resolve("git");
        }
      };
    })(this));
    return deferred.promise;
  };

  Sync.prototype._cloneRepository = function() {
    var deferred;
    deferred = Q.defer();
    this.logger.info("emptying backup directory '" + this._source + "'");
    FS.removeTree(this._source).then((function(_this) {
      return function() {
        return FS.makeTree(_this._source);
      };
    })(this)).then((function(_this) {
      return function() {
        _this.logger.info("start to clone git repository '" + _this._gitUrl + "' into '" + _this._source + "'");
        _this.logger.info(_this._wrapGit("git clone " + _this._gitUrl + " " + _this._source));
        return exec(_this._wrapGit("git clone " + _this._gitUrl + " " + _this._source), {
          cwd: _this._source
        }, function(err, stdout, stderr) {
          _this.logger.info("CLONE GIT result:\n" + (stdout !== "" ? stdout : stderr));
          if (err !== null) {
            return deferred.reject(err);
          } else {
            return deferred.resolve("success");
          }
        });
      };
    })(this));
    return deferred.promise;
  };

  Sync.prototype._wrapGit = function(command) {
    return "GIT_SSH=" + (path.resolve(this.config.get("basePath"), this.config.get("git:sshShell"))) + " " + command;
  };

  Sync.prototype._pullRepository = function() {
    var deferred;
    this.logger.info("start to pull git repository into '" + this._source + "'");
    deferred = Q.defer();
    exec(this._wrapGit("git clean -xdf"), {
      cwd: this._source
    }, (function(_this) {
      return function(err, stdout, stderr) {
        _this.logger.info("GIT ClEAN result:\n" + (stdout !== "" ? stdout : stderr));
        if (err !== null) {
          return deferred.reject(err);
        } else {
          return exec(_this._wrapGit("git pull --ff"), {
            cwd: _this._source
          }, function(err, stdout, stderr) {
            _this.logger.info("GIT PULL result:\n" + (stdout !== "" ? stdout : stderr));
            if (err !== null) {
              return deferred.reject(err);
            } else {
              return deferred.resolve("success");
            }
          });
        }
      };
    })(this));
    return deferred.promise;
  };

  Sync.prototype.syncGit = function(command) {
    return Q.all([Sync.initFolders(this._source, this._dest), this.updateFlagIndicators()]).then((function(_this) {
      return function() {
        if (!_this._flags.stopContentDelivery) {
          return _this._checkRepositoryStatus().then(function(result) {
            if (result === "not git") {
              return _this._cloneRepository();
            } else {
              return Q.resolve("success");
            }
          }).then(function(result) {
            if (result === "success") {
              return _this._pullRepository();
            } else {
              return Q.reject("fail");
            }
          }).then(function(result) {
            if (result === "success") {
              return _this.syncLocal(command);
            } else {
              return Q.reject("fail");
            }
          });
        } else {
          _this.logger.info("content delivery file was found");
          return Q.resolve("content delivery file was found");
        }
      };
    })(this));
  };

  Sync.prototype.syncHttp = function(command) {
    this.logger.info("syncHttp message content: '" + (util.inspect(command, {
      depth: null
    })) + "'");
    return Q.all([Sync.initFolders(this._source, this._dest), this.updateFlagIndicators()]).then((function(_this) {
      return function() {
        var changeSet, formUrl;
        if (!_this._flags.stopContentDelivery) {
          _this.logger.info("sync http");
          formUrl = "http://" + command.host + ":" + command.port;
          formUrl += "/" + (_this.config.get("client:customerId"));
          formUrl += "/" + (_this.config.get("client:hostId"));
          formUrl += "/" + (_this.config.get("client:contentRegion"));
          formUrl += "/" + command.snapshot.id;
          _this.logger.info("syncHttp server url: '" + formUrl + "'");
          changeSet = command.snapshot.changeSet;
          return Q.all([
            async.eachLimit(changeSet.added.concat(changeSet.modified), 5, function(added) {
              var dirname, rQ, req, wQ, writeStream;
              wQ = Q.defer();
              dirname = path.dirname(path.join(_this._source, _this.config.get("client:contentRegion"), added));
              fs.mkdirpSync(dirname);
              writeStream = fs.createWriteStream(path.join(_this._source, _this.config.get("client:contentRegion"), added));
              writeStream.on("finish", function() {
                return wQ.resolve();
              });
              writeStream.on("close", function() {
                return wQ.reject();
              });
              rQ = Q.defer();
              req = request("" + formUrl + added).pipe(writeStream);
              req.on("end", function() {
                return rQ.resolve();
              });
              req.on("close", function() {
                return rQ.reject();
              });
              return Q.all([wQ, rQ]);
            }), async.eachLimit(changeSet.deleted, 5, function(deleted) {
              return FS.removeTree(path.join(_this._source, _this.config.get("client:contentRegion"), deleted));
            })
          ]);
        } else {
          _this.logger.info("content delivery file was found");
          return Q.resolve("content delivery file was found");
        }
      };
    })(this)).then((function(_this) {
      return function() {
        return _this.syncLocal(command);
      };
    })(this));
  };

  Sync.prototype.syncLocal = function(command) {
    var deferred;
    deferred = Q.defer();
    Q.all([Sync.initFolders(this._source, this._dest), this.updateFlagIndicators()]).then((function(_this) {
      return function() {
        if (!_this._flags.stopContentDelivery) {
          _this._rsync.source(path.join(_this._source, _this.config.get("client:contentRegion") + "/")).destination(_this._dest);
          return _this._rsync.execute(function(err, resultCode) {
            var result;
            if (err) {
              deferred.reject(err);
            }
            result = resultCode === 0 ? "success" : "fail";
            _this.logger.info("LOCAL RSYNC result:\n'" + result + "';\nlocal sync from '" + _this._source + "' to '" + _this._dest + "';");
            return deferred.resolve(result);
          });
        } else {
          _this.logger.info("content delivery file was found");
          return deferred.resolve("content delivery file was found");
        }
      };
    })(this));
    return deferred.promise;
  };

  Sync.prototype._logChanges = function(result, key) {
    if (this._lastKey !== key) {
      this.logger.info("" + (key != null ? "as " + key + " was found => " : "") + result);
      return this._lastKey = key;
    }
  };

  Sync.prototype.startAutoSync = function() {
    if (this.intervalId == null) {
      return this.intervalId = setInterval((function(_this) {
        return function() {
          return _this._syncAuto();
        };
      })(this), 10000);
    }
  };

  Sync.prototype.stopAutoSync = function() {
    if (this.intervalId != null) {
      clearInterval(this.intervalId);
      return delete this.intervalId;
    }
  };

  Sync.prototype.syncReset = function() {
    var deferred;
    deferred = Q.defer();
    this.pushCommand({
      name: "sync-backup"
    }).then((function(_this) {
      return function(result) {
        return setTimeout(function() {
          return _this.pushCommand({
            name: "sync-backup"
          }).then(function(result) {
            return deferred.resolve(result);
          });
        }, 10000);
      };
    })(this));
    return deferred.promise;
  };

  Sync.prototype._syncAuto = function() {
    return this.updateFlagIndicators().then((function(_this) {
      return function() {
        if (_this._flags.stopContentDelivery) {
          return _this._logChanges('content delivery stopped', 'stopContentDelivery');
        } else {
          if (_this._lastKey === "stopContentDelivery") {
            _this._logChanges('content delivery restarted');
            return _this.syncReset();
          } else if (_this._flags.stopPeriodicRsync === true) {
            return _this._logChanges('periodic local syncstopped', 'stopPeriodicRsync');
          } else {
            _this._logChanges('periodic local sync started');
            return _this.pushCommand({
              name: "sync-local"
            });
          }
        }
      };
    })(this));
  };

  return Sync;

})(events.EventEmitter);

module.exports = Sync;
